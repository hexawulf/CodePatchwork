# Shared (Types & Schemas) - AGENTS.md

## Package Identity

**What**: Shared TypeScript types and database schemas for CodePatchwork  
**Tech**: Drizzle ORM + Zod validation  
**Purpose**: Single source of truth for database schema and validation rules shared between client and server

---

## Setup & Push Changes

```bash
# After editing schema.ts, push changes to database
npm run db:push

# This runs: drizzle-kit push
# - Generates SQL migrations
# - Applies changes to PostgreSQL
# - Updates migrations/ directory
```

---

## Patterns & Conventions

### File Organization

```
shared/
├── schema.ts        # All Drizzle tables + Zod schemas
└── schema.ts.backup # Backup (ignore this)
```

**Everything lives in `schema.ts`** — one file for all tables and types.

---

## Schema Structure

### Pattern: Table Definition → Zod Schema → Types

```typescript
// 1. Define Drizzle table (database schema)
export const snippets = pgTable("snippets", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  code: text("code").notNull(),
  userId: text("userid"),  // Note: DB column is lowercase "userid"
  createdAt: timestamp("createdat").defaultNow().notNull(),
});

// 2. Create Zod schema for validation (INSERT operations)
export const insertSnippetSchema = createInsertSchema(snippets).omit({
  id: true,           // Auto-generated
  createdAt: true,    // Auto-generated
  updatedAt: true,    // Auto-generated
});

// 3. Export TypeScript types
export type InsertSnippet = z.infer<typeof insertSnippetSchema>;
export type Snippet = typeof snippets.$inferSelect;
```

### Key Concepts

1. **Table Definition**: Drizzle `pgTable()` defines database structure
2. **Insert Schema**: Zod schema for validating user input (omits auto-generated fields)
3. **Insert Type**: TypeScript type for validated insert data
4. **Select Type**: TypeScript type for database row (includes all fields)

---

## Database Tables

### Current Tables

```
users             → User accounts (Firebase UIDs)
snippets          → Code snippets
collections       → User-created snippet collections
collection_items  → Many-to-many: snippets ↔ collections
comments          → Comments on snippets
```

### Table Relationships

```
users
  ├─→ snippets (one-to-many)
  ├─→ collections (one-to-many)
  └─→ comments (one-to-many)

snippets
  ├─→ comments (one-to-many)
  └─→ collection_items (many-to-many via collections)

collections
  └─→ collection_items (one-to-many)
```

---

## Naming Conventions

### CRITICAL: Database Column Naming

**Issue**: PostgreSQL columns are **lowercase**, TypeScript properties are **camelCase**.

```typescript
// ✅ Good: Drizzle maps TS → DB automatically
export const snippets = pgTable("snippets", {
  userId: text("userid"),           // TS: userId, DB: userid
  createdAt: timestamp("createdat"), // TS: createdAt, DB: createdat
  viewCount: integer("viewcount"),   // TS: viewCount, DB: viewcount
});

// When you use it in code:
snippet.userId    // ✅ TypeScript property (camelCase)
snippet.createdAt // ✅ TypeScript property (camelCase)

// Drizzle generates SQL with DB column names:
// SELECT userid, createdat FROM snippets
```

**Rule**: Always use TypeScript property names in application code. Drizzle handles the database mapping.

---

## Preferred Patterns

### ✅ DO: Use createInsertSchema for Validation

```typescript
// ✅ Good: Generate Zod schema from Drizzle table
import { createInsertSchema } from "drizzle-zod";

export const insertSnippetSchema = createInsertSchema(snippets).omit({
  id: true,         // Auto-generated by database
  createdAt: true,  // Auto-generated by database
  updatedAt: true,  // Auto-generated by database
});

// Usage in routes:
const validated = insertSnippetSchema.parse(req.body);

// ❌ Bad: Manual Zod schema (duplicates logic)
const manualSchema = z.object({
  title: z.string(),
  code: z.string(),
  // ... (hard to keep in sync with table definition)
});
```

### ✅ DO: Export Both Insert and Select Types

```typescript
// ✅ Good: Export both types
export type InsertSnippet = z.infer<typeof insertSnippetSchema>;
export type Snippet = typeof snippets.$inferSelect;

// Insert type: For creating new records (no id, createdAt, etc.)
const newSnippet: InsertSnippet = {
  title: "My Snippet",
  code: "console.log('hello');",
  userId: "user123"
};

// Select type: For records from database (has id, createdAt, etc.)
const existingSnippet: Snippet = {
  id: 1,
  title: "My Snippet",
  code: "console.log('hello');",
  userId: "user123",
  createdAt: new Date(),
  updatedAt: new Date(),
  // ... all fields
};
```

### ✅ DO: Use Drizzle Constraints

```typescript
// ✅ Good: Use Drizzle modifiers
export const snippets = pgTable("snippets", {
  id: serial("id").primaryKey(),              // Primary key
  title: text("title").notNull(),             // NOT NULL
  email: text("email").unique(),              // UNIQUE constraint
  shareId: text("shareid").unique(),          // UNIQUE constraint
  tags: text("tags").array(),                 // Array type
  createdAt: timestamp("createdat").defaultNow(), // Default value
});

// ❌ Bad: Missing constraints (database allows bad data)
export const snippets = pgTable("snippets", {
  id: serial("id"),          // No primary key
  title: text("title"),      // Nullable (should be notNull)
});
```

### ✅ DO: Document Column Mappings

```typescript
// ✅ Good: Comment on mappings
export const snippets = pgTable("snippets", {
  // TS property "userId" maps to DB column "userid"
  userId: text("userid"),
  // TS property "createdAt" maps to DB column "createdat"
  createdAt: timestamp("createdat", { withTimezone: true }).defaultNow(),
});
```

### ❌ DON'T: Mix Table Definitions with Business Logic

```typescript
// ❌ Bad: Functions in schema file
export function formatSnippet(snippet: Snippet) {
  // This belongs in a utility file, not schema.ts
}

// ✅ Good: Only table definitions and types in schema.ts
export const snippets = pgTable(/* ... */);
export type Snippet = typeof snippets.$inferSelect;
```

---

## Touch Points / Key Files

- **Main Schema**: `shared/schema.ts` - ALL tables and types
- **Drizzle Config**: `drizzle.config.ts` (in root) - Database connection for migrations
- **Migrations**: `migrations/` directory (auto-generated by `drizzle-kit`)

---

## JIT Index Hints

```bash
# Find all tables
rg -n "export const.*=.*pgTable" shared/schema.ts

# Find all insert schemas
rg -n "createInsertSchema" shared/schema.ts

# Find all exported types
rg -n "export type" shared/schema.ts

# Check Drizzle config
cat drizzle.config.ts

# List generated migrations
ls migrations/

# Verify database connection
npm run db:push
```

---

## Adding a New Table

### Step-by-Step Example

```typescript
// 1. Define the table in shared/schema.ts
export const tags = pgTable("tags", {
  id: serial("id").primaryKey(),
  name: text("name").notNull().unique(),
  userId: text("userid"),
  createdAt: timestamp("createdat").defaultNow().notNull(),
});

// 2. Create insert schema
export const insertTagSchema = createInsertSchema(tags).omit({
  id: true,
  createdAt: true,
});

// 3. Export types
export type InsertTag = z.infer<typeof insertTagSchema>;
export type Tag = typeof tags.$inferSelect;

// 4. Push to database
// Run: npm run db:push

// 5. Use in server (storage.ts)
async getTags(): Promise<Tag[]> {
  return await db.select().from(tags);
}

// 6. Use in client
import { type Tag } from "@shared/schema";
const { data: tags } = useQuery<Tag[]>({ queryKey: ["/api/tags"] });
```

---

## Modifying an Existing Table

### Adding a Column

```typescript
// Before:
export const snippets = pgTable("snippets", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  code: text("code").notNull(),
});

// After: Add "language" column
export const snippets = pgTable("snippets", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  code: text("code").notNull(),
  language: text("language").notNull(),  // NEW COLUMN
});

// Push changes to database:
npm run db:push

// Drizzle Kit will generate:
// ALTER TABLE snippets ADD COLUMN language TEXT NOT NULL;
```

**Note**: If adding a `notNull()` column to a table with existing data, you must provide a default value or handle migration manually.

---

## Common Gotchas

### 1. Column Name Casing

```typescript
// ✅ Good: Always specify lowercase DB column name
userId: text("userid"),  // DB: userid, TS: userId

// ❌ Bad: Drizzle defaults to TS name (causes issues)
userId: text(),  // DB: userId (camelCase in DB — confusing!)
```

### 2. Omit Auto-Generated Fields in Insert Schemas

```typescript
// ✅ Good: Omit id, createdAt, updatedAt
export const insertSnippetSchema = createInsertSchema(snippets).omit({
  id: true,
  createdAt: true,
  updatedAt: true,
});

// ❌ Bad: Including auto-generated fields
export const insertSnippetSchema = createInsertSchema(snippets);
// Now users could set id, createdAt manually (bad!)
```

### 3. Array Types Require Postgres Array Syntax

```typescript
// ✅ Good: Use .array() for PostgreSQL arrays
tags: text("tags").array(),

// In database: TEXT[]
// In TypeScript: string[]

// ❌ Bad: text() without .array()
tags: text("tags"),  // Would store stringified JSON, not array
```

### 4. Timestamps Should Use `withTimezone: true`

```typescript
// ✅ Good: Use timezone-aware timestamps
createdAt: timestamp("createdat", { withTimezone: true }).defaultNow(),

// ❌ Bad: No timezone (causes issues with date-fns and comparisons)
createdAt: timestamp("createdat").defaultNow(),
```

---

## Pre-PR Checks

Before creating a pull request that modifies `schema.ts`:

```bash
# 1. Push schema to database (test migration)
npm run db:push

# 2. Verify no TypeScript errors
npm run check

# 3. Check server storage.ts uses new types
rg -n "from.*@shared/schema" server/storage.ts

# 4. Check client uses new types
rg -n "from.*@shared/schema" client/src/

# 5. Verify migrations were generated
ls migrations/ -la
```

---

## Type Import Examples

### In Server (server/storage.ts)

```typescript
import {
  users, type User, type InsertUser,
  snippets, type Snippet, type InsertSnippet,
  collections, type Collection, type InsertCollection,
} from "@shared/schema";
```

### In Client (client/src/components/SnippetCard.tsx)

```typescript
import { type Snippet } from "@shared/schema";

interface SnippetCardProps {
  snippet: Snippet;
}
```

### In API Routes (server/routes.ts)

```typescript
import { insertSnippetSchema } from "@shared/schema";

app.post("/api/snippets", authMiddleware, async (req, res) => {
  const validated = insertSnippetSchema.parse(req.body);
  // ...
});
```

---

## Database Migration Workflow

```bash
# 1. Edit shared/schema.ts (add/modify table)

# 2. Push to database
npm run db:push
# - Drizzle Kit generates SQL migration
# - Applies migration to database
# - Saves migration in migrations/ directory

# 3. Commit changes
git add shared/schema.ts migrations/
git commit -m "Add tags table"

# 4. Deploy (production)
npm run db:push  # Applies migrations on production database
```

---

## Drizzle Config (drizzle.config.ts)

```typescript
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  out: "./migrations",            // Where to save migrations
  schema: "./shared/schema.ts",   // Source of truth
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL,
  },
});
```

**Important**: The schema path must point to `shared/schema.ts`.

---

## Example: Complete Table Definition

```typescript
// Users table (for reference)
export const users = pgTable("users", {
  id: varchar("id").primaryKey(),           // Firebase UID
  email: text("email").unique(),            // Unique email
  displayName: text("display_name"),        // Display name
  photoURL: text("photo_url"),              // Avatar URL
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export const insertUserSchema = createInsertSchema(users).omit({
  createdAt: true,
  updatedAt: true,
});

export type InsertUser = z.infer<typeof insertUserSchema>;
export type User = typeof users.$inferSelect;
```

This is the gold standard for table definitions in this project.
